-- tsql
create database db1;
go

use db1;
go

create login l1 with password='123';
go

create user ownera for login l1;
go

create login l2 with password='123';
go

create user ownerb for login l2;
go

create login invoker with password='123';
go

create user invoker for login invoker;
go

use master
go

-- psql
grant all on database jdbc_testdb to db1_ownera;
go

grant all on database jdbc_testdb to db1_ownerb;
go

-- tsql user=l2 password=123
use db1;
go

create schema hasownerb;
go

create table hasownerb.tbld(a int, b int, c int);
go

insert into hasownerb.tbld values(1, 1, 1);
go

create view hasownerb.vwd as select current_user;
go

create proc hasownerb.procd as select current_user;
go

create function hasownerb.funcd() returns sys.nvarchar(30) as
begin
	return 'inside function funcd';
end;
go

-- tsql user=l1 password=123
use db1;
go

create schema hasownera;
go

create table hasownera.tbls(a int, b int, c int);
go

insert into hasownera.tbls values(1, 1, 1);
go

create view hasownera.vws as select current_user;
go

create proc hasownera.procs as select current_user;
go

create function hasownera.funcs() returns sys.nvarchar(30) as
begin
	return 'inside function funcs';
end;
go

-- create trigger hasownera.trigs
-- on hasownera.tbls
-- after insert
-- as select 'inside trigger trigs';
-- go

-- CASE 1
-- PROC/FUNC
-- 		SELECT/EXEC ON TABLE/VIEW/PROC/FUNC/TRIGGER
-- END
-- EXEC PROC/FUNC

-- Positive test for procedure
create proc hasownera.pa1 as
	select * from hasownera.tbls;
	select * from hasownera.vws;
	exec hasownera.procs;
	select hasownera.funcs();
	-- For trigger execution
	-- insert into hasownera.tbls values(1,1,1);
go

grant exec on hasownera.pa1 to invoker;
go

-- Positive test for function
create function hasownera.fa1() returns table as
return (select * from hasownera.tbls, hasownera.vws);
go

grant exec on hasownera.fa1 to invoker;
go

create function hasownera.fb1() returns table as
return (select hasownera.funcs());
go

grant exec on hasownera.fb1 to invoker;
go

create function hasownera.fc1() returns int
as
begin
	declare @temp_fb1 table(cur_user sys.sysname);
	insert into @temp_fb1 (cur_user) exec hasownera.procs;
	return (select count(*) from @temp_fb1);
end
go

grant exec on hasownera.fc1 to invoker;
go

-- Negative test for table inside proc/func
create proc hasownera.pb1 as select * from hasownerb.tbld;
go

grant exec on hasownera.pb1 to invoker;
go

-- Negative test for view inside proc/func
create proc hasownera.pc1 as select * from hasownerb.vwd;
go

grant exec on hasownera.pc1 to invoker;
go

create function hasownera.fe1() returns table as
return (select * from hasownerb.tbld, hasownerb.vwd);
go

grant exec on hasownera.fe1 to invoker;
go

-- Negative test for proc inside proc/func
create proc hasownera.pd1 as exec hasownerb.procd;
go

grant exec on hasownera.pd1 to invoker;
go

create function hasownera.ff1() returns int
as
begin
	declare @temp_ff1 table(cur_user sys.sysname);
	insert into @temp_ff1 (cur_user) exec hasownerb.procd;
	return (select count(*) from @temp_ff1);
end
go

grant exec on hasownera.ff1 to invoker;
go

-- Negative test for function inside proc/func
create proc hasownera.pe1 as select hasownerb.funcd();
go

grant exec on hasownera.pe1 to invoker;
go

create function hasownera.fg1() returns table as
return (select hasownerb.funcd());
go

grant exec on hasownera.fg1 to invoker;
go

-- tsql user=invoker password=123
use db1;
go

select * from hasownera.tbls;
go

select * from hasownera.vws;
go

exec hasownera.procs;
go

select * from hasownera.fa1();
go

select * from hasownera.fb1();
go

select hasownera.fc1();
go

exec hasownera.pa1;
go

-- Execution using SP_PREPARE
DECLARE @handle int;
EXEC SP_PREPARE @handle OUT, NULL, 'EXEC hasownera.pa1;'
EXEC SP_EXECUTE @handle
EXEC SP_EXECUTE @handle
EXEC SP_EXECUTE @handle
EXEC SP_UNPREPARE @handle
GO

DECLARE @handle int;
EXEC SP_PREPARE @handle OUT, NULL, 'SELECT * from hasownera.fa1();'
EXEC SP_EXECUTE @handle
EXEC SP_EXECUTE @handle
EXEC SP_EXECUTE @handle
EXEC SP_UNPREPARE @handle
GO

-- Execution for negative tests
exec hasownera.pb1;
go

exec hasownera.pc1;
go

exec hasownera.pd1;
go

exec hasownera.pe1;
go

select * from hasownera.fe1();
go

select hasownera.ff1();
go

select * from hasownera.fg1();
go

-- tsql
use db1;
go

drop proc hasownera.pa1, hasownera.pb1, hasownera.pc1, hasownera.pd1, hasownera.pe1;
go

drop function hasownera.fa1, hasownera.fb1, hasownera.fc1, hasownera.fe1, hasownera.ff1, hasownera.fg1;
go

use master;
go

-- CASE 2
-- PROC1 with ownerB
--		PROC2 with ownerA
--			SELECT ON TABLE/VIEW/PROC with ownerA
-- GRANT EXEC ON PROC1 to invoker
-- GRANT EXEC ON PROC2 to inovker
-- EXEC PROC1 

-- tsql user=l1 password=123
use db1;
go

create proc hasownera.pa2 as begin
	select * from hasownera.tbls;
	select * from hasownera.vws;
	exec hasownera.procs;
end;
go

grant exec on hasownera.pa2 to invoker;
go

-- tsql user=l2 password=123
use db1;
go

create proc hasownerb.pb2 as exec hasownera.pa2;
go

grant exec on hasownerb.pb2 to invoker;
go

select objs.column1 as object,user_name(objectproperty(object_id(objs.column1),'OwnerId')) as owner
from (values ('hasownerb.pb2'), ('hasownera.pa2'), ('hasownera.tbls')) 
as objs(object_name)
go

-- tsql user=invoker password=123
use db1;
go

exec hasownerb.pb2;
go

-- tsql
use db1;
go

drop proc hasownerb.pb2;
go

drop proc hasownera.pa2;
go

use master;
go

-- CASE 3
-- PROC->VIEW->VIEW->TABLE
-- PROCA
--	SELECT FROM VIEWB
-- VIEWB
-- 	SELECT FROM VIEWA
-- VIEWA
-- SELECT FROM TABLEA

-- tsql user=l1 password=123
use db1;
go

create view hasownera.vwa3 as select * from hasownera.tbls;
go

create view hasownera.vwb3 as select * from hasownera.vwa3;
go

create proc hasownera.pa3 as begin
	select * from hasownera.vwb3;
end;
go

grant exec on hasownera.pa3 to invoker;
go

-- tsql
select objs.column1 as object,user_name(objectproperty(object_id(objs.column1),'OwnerId')) as owner
from (values ('hasownerb.pb2'), ('hasownera.pa2'), ('hasownera.tbls')) 
as objs(object_name)
go

-- tsql user=invoker password=123
use db1;
go

exec hasownera.pa3;
go

select * from hasownera.tbls;
go

select * from hasownera.vwa3;
go

select * from hasownera.vwb3;
go

-- tsql
use db1;
go

drop proc hasownera.pa3;
go

drop view hasownera.vwb3;
go

drop view hasownera.vwa3;
go

use master;
go

-- CASE 4
-- PROC/FUNC
--	EXEC(SELECT FROM TABLE)
-- ownership chain shouldn't work for this case
-- tsql user=l1 password=123
use db1;
go

create proc hasownera.pa4 as begin
	exec('select * from hasownera.tbls');
end;
go

grant exec on hasownera.pa4 to invoker;
go

-- tsql user=invoker password=123
use db1;
go

exec hasownera.pa4;
go

-- tsql
use db1;
go

drop proc hasownera.pa4;
go

use master;
go

-- Cleanup
-- psql
-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) in ('l1','l2','invoker') AND backend_type = 'client backend' AND usesysid IS NOT NULL;
GO

-- Wait to sync with another session
SELECT pg_sleep(1);
GO

revoke all on database jdbc_testdb from db1_ownera;
go

revoke all on database jdbc_testdb from db1_ownerb;
go

-- tsql
use db1;
go

-- drop trigger hasownera.trigs;
-- go

drop function hasownera.funcs;
go

drop proc hasownera.procs;
go

drop view hasownera.vws;
go

drop table hasownera.tbls;
go

drop function hasownerb.funcd;
go

drop proc hasownerb.procd;
go

drop view hasownerb.vwd;
go

drop table hasownerb.tbld;
go

drop schema hasownerb;
go

drop schema hasownera;
go

drop user ownera;
go

drop user ownerb;
go

drop user invoker;
go

use master;
go

drop database db1;
go

drop login l1;
go

drop login l2;
go

drop login invoker;
go

