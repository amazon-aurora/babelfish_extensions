-- test table, trigger, procedure, function
SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_t1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_proc1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_func1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_v1'))
GO

SELECT (CASE WHEN OBJECT_ID('babel_object_id_trg') = NULL THEN 'false' ELSE 'true' END) result;
GO

-- We can also specify object_type as parameter
SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_t1', 'U'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_proc1', 'P'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_func1', 'FN'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_v1', 'V'))
GO


-- traling spaces
SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_t1    '))
GO

-- Case insensitive
SELECT OBJECT_NAME(OBJECT_ID('Babel_Object_ID_t1'))
GO

-- leading spaces should fail
SELECT (CASE WHEN OBJECT_NAME(OBJECT_ID('   babel_object_id_t1')) = 'babel_object_id_t1' THEN 'true' ELSE 'false' END) result;
GO

-- testing different scenarios of 3-part name 
SELECT OBJECT_NAME(OBJECT_ID('dbo.babel_object_id_t1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('..babel_object_id_t1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('master.dbo.babel_object_id_t1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('[master]."dbo".[babel_object_id_t1]'))
GO

SELECT OBJECT_NAME(OBJECT_ID('"master".[dbo]."babel_object_id_t1"'))
GO

SELECT OBJECT_NAME(OBJECT_ID('master..babel_object_id_t1'))
GO

-- schema and object name containing spaces and dots
SELECT OBJECT_NAME(OBJECT_ID('[babel_object_id_t2 .with .dot_an_spaces]'));
GO

SELECT OBJECT_NAME(OBJECT_ID('master.."babel_object_id_t2 .with .dot_an_spaces"'));
GO

SELECT OBJECT_NAME(OBJECT_ID('[babel_object_id_schema .with .dot_and_spaces]."babel_object_id_t3 .with .dot_and_spaces"'));
GO

-- To test temp object
CREATE TABLE #babel_object_id_temp_t1 (a int);
GO

SELECT OBJECT_NAME(OBJECT_ID('#babel_object_id_temp_t1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('tempdb..#babel_object_id_temp_t1'))
GO

-- We can also specify object_type as parameter
SELECT OBJECT_NAME(OBJECT_ID('#babel_object_id_temp_t1', 'U'))
GO
 
DROP TABLE #babel_object_id_temp_t1;
go

-- test dependency of user's permission on object
USE master;
GO

CREATE LOGIN babel_object_id_login1 WITH PASSWORD = '12345678';
GO

CREATE USER babel_object_id_master_user1 FOR LOGIN babel_object_id_login1;
GO

USE babel_object_id_db;
GO

CREATE USER babel_object_id_user2 FOR LOGIN babel_object_id_login1;
GO

-- tsql      user=babel_object_id_login1 password=12345678
USE master
GO

SELECT current_user;
GO

-- by default user will not access to any objects
-- following should return NULL
SELECT OBJECT_ID('babel_object_id_t1')
GO

SELECT OBJECT_ID('babel_object_id_proc1')
GO

SELECT OBJECT_ID('babel_object_id_func1')
GO

SELECT OBJECT_ID('babel_object_id_v1')
GO

SELECT OBJECT_ID('babel_object_id_trg')
GO

-- Grant permission to user
-- tsql
GRANT SELECT ON babel_object_id_t1 TO babel_object_id_master_user1;
GO

GRANT EXECUTE ON babel_object_id_proc1 TO babel_object_id_master_user1;
GO

GRANT EXECUTE ON babel_object_id_func1 TO babel_object_id_master_user1;
GO

GRANT SELECT ON babel_object_id_v1 TO babel_object_id_master_user1;
GO

-- Note: for triggers and constraint it will check permission of table it belongs
-- tsql      user=babel_object_id_login1 password=12345678
SELECT current_user;
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_t1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_proc1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_func1'))
GO

SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_v1'))
GO

SELECT (CASE WHEN OBJECT_ID('babel_object_id_trg') = NULL THEN 'false' ELSE 'true' END) result;
GO


-- Revoke permission from user
-- tsql
REVOKE SELECT ON babel_object_id_t1 FROM babel_object_id_master_user1;
GO

REVOKE EXECUTE ON babel_object_id_proc1 FROM babel_object_id_master_user1;
GO

REVOKE EXECUTE ON babel_object_id_func1 FROM babel_object_id_master_user1;
GO

REVOKE SELECT ON babel_object_id_v1 FROM babel_object_id_master_user1;
GO


-- test cross database lookup
-- tsql  user=babel_object_id_login1 password=12345678
USE master;
GO

SELECT current_user;
GO

-- following should return NULL, as user in db corresponding to current login still don't have permission
SELECT OBJECT_ID('babel_object_id_db..babel_object_id_db_t1')
GO

-- tsql
-- grant permission for access
USE babel_object_id_db
GO

GRANT SELECT ON babel_object_id_db_t1 TO babel_object_id_user2;
GO

-- tsql    user=babel_object_id_login1 password=12345678
USE master;
GO

SELECT current_user;
GO

-- Now we can access
SELECT OBJECT_NAME(OBJECT_ID('babel_object_id_db..babel_object_id_db_t1'))
GO

-- tsql
USE babel_object_id_db
GO

REVOKE SELECT ON babel_object_id_db_t1 FROM babel_object_id_user2;
GO

DROP USER babel_object_id_user2
GO

USE master;
GO

DROP USER babel_object_id_master_user1
GO

-- psql

-- Need to terminate active session before cleaning up the login
SELECT pg_terminate_backend(pid) FROM pg_stat_get_activity(NULL)
WHERE sys.suser_name(usesysid) = 'babel_object_id_login1'
AND backend_type = 'client backend' AND usesysid IS NOT NULL;
GO
-- Wait to sync with another session
SELECT pg_sleep(1);
GO

-- tsql
DROP LOGIN babel_object_id_login1;
GO