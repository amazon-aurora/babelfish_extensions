-- The default scale is 2 in PG.
select CAST('$100,123.4567' AS money);
GO
~~START~~
money
100123.4567
~~END~~

-- Currency symbol followed by number without being quoted is not recognized
-- as Money in postgres dialect.
select CAST($100123.4567 AS money);
GO
~~START~~
money
100123.4567
~~END~~


-- Scale changes to the sql server default 4 in tsql dialect
-- Currency symbol followed by number without being quoted is recognized
-- as Money type in tsql dialect.
DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
select CAST($100123.4567 AS money);
GO
~~START~~
money
100123.4567
~~END~~

select CAST($100123. AS money);
GO
~~START~~
money
100123.0000
~~END~~

select CAST($.4567 AS money);
GO
~~START~~
money
0.4567
~~END~~

select CAST('$100,123.4567' AS money);
GO
~~START~~
money
100123.4567
~~END~~


-- Test numeric types with brackets
create table testing_1 (a [tinyint]);
GO
drop table testing_1;
GO
create table testing_1 (a [smallint]);
GO
drop table testing_1;
GO
create table testing_1 (a [int]);
GO
drop table testing_1;
GO
create table testing_1 (a [bigint]);
GO
drop table testing_1;
GO
create table testing_1 (a [real]);
GO
drop table testing_1;
GO
create table testing_1 (a [float]);
GO
drop table testing_1;
GO

-- Comma separated format without quote is not allowed in sql server
select CAST($100,123.4567 AS money);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'AS' at line 2 and character position 26)~~


-- Smallmoney in tsql dialect
select CAST($100123.4567 AS smallmoney);
GO
~~START~~
smallmoney
100123.4567
~~END~~

select CAST('$100,123.4567' AS smallmoney);
GO
~~START~~
smallmoney
100123.4567
~~END~~

-- Comma separated format without quote is not allowed in sql server
select CAST($100,123.4567 AS smallmoney);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'AS' at line 2 and character position 26)~~


create table testing_1(mon money, smon smallmoney);
GO
insert into testing_1 (mon, smon) values ('$100,123.4567', '$123.9999');
insert into testing_1 (mon, smon) values ($100123.4567, $123.9999);
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

select * from testing_1;
GO
~~START~~
money#!#smallmoney
100123.4567#!#123.9999
100123.4567#!#123.9999
~~END~~

select avg(CAST(mon AS numeric(38,4))), avg(CAST(smon AS numeric(38,4))) from testing_1;
GO
~~START~~
numeric#!#numeric
100123.456700#!#123.999900
~~END~~

select mon+smon as total from testing_1;
GO
~~START~~
money
100247.4566
100247.4566
~~END~~

-- Comma separated format without quote is not allowed in sql server
insert into testing_1 (mon, smon) values ($100,123.4567, $123.9999);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: INSERT has more expressions than target columns)~~


-- Test other allowed currency symbols with/without quote
select CAST(€100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST('€100.123' AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(¢100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(£100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST('£100.123' AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(¤100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(¥100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(৲100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(৳100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(฿100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(៛100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₠100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₡100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₢100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₣100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₤100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₥100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₦100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₧100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₨100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₩100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₪100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₫100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₭100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₮100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₯100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₰100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(₱100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(﷼100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(﹩100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(＄100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(￠100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(￡100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(￥100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST('￥100.123' AS money);
GO
~~START~~
money
100.1230
~~END~~

select CAST(￦100.123 AS money);
GO
~~START~~
money
100.1230
~~END~~


-- Test unsupoorted currency symbol
select CAST(￩100.123 AS money);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '￩' at line 2 and character position 12)~~

select CAST('￩100.123' AS money);
GO
~~START~~
money
100.1230
~~END~~


-- Test that space is allowed between currency symbol and number, this is
-- a TSQL behavior
select CAST($   123.5 AS money);
GO
~~START~~
money
123.5000
~~END~~

select CAST('$    123.5' AS money);
GO
~~START~~
money
123.5000
~~END~~


-- Test inexact result mutliply/divide money with money, to match
-- SQL Server behavior
select CAST(100 AS money)/CAST(339 AS money)*CAST(10000 AS money);
GO
~~START~~
money
2949.0000
~~END~~


-- Test postgres dialect
-- Test currency symbol without quote is not allowed in postgres dialect
reset babelfishpg_tsql.sql_dialect;
select CAST(€100.123 AS money);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 3 and character position 22)~~


-- Test exact result multiply/divide money with money in postgres dialect
select CAST(100 AS money)/CAST(339 AS money)*CAST(10000 AS money);
GO
~~START~~
money
2949.0000
~~END~~


-- Clean up
drop table testing_1;
GO

-- BABEL-109 test no more not unique operator error caused by fixeddeciaml
select CAST(2 AS numeric) > 1;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '>' at line 2 and character position 26)~~

select CAST(2 AS decimal) > 1;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '>' at line 1 and character position 26)~~


-- Test that numeric > int and fixeddecimal > int is different
select CAST(2.00001 AS numeric) > 2;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '>' at line 2 and character position 32)~~

select CAST(2.00001 AS sys.fixeddecimal) > 2;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '>' at line 1 and character position 41)~~











-- -- test TSQL Money (based on fixeddecimal) cross datatype operators
-- DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
-- GO
-- select CAST(2 AS money) > 1;
-- GO
-- select CAST(2 AS money) > CAST(1 AS int);
-- GO
-- select CAST(2 AS money) > CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) > CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) > CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) > CAST(1 AS decimal);
-- GO
-- select CAST(2 AS money) >= 1;
-- GO
-- select CAST(2 AS money) >= CAST(1 AS int);
-- GO
-- select CAST(2 AS money) >= CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) >= CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) >= CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) >= CAST(1 AS decimal);
-- GO
-- select CAST(2 AS money) < 1;
-- GO
-- select CAST(2 AS money) < CAST(1 AS int);
-- GO
-- select CAST(2 AS money) < CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) < CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) < CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) < CAST(1 AS decimal);
-- GO
-- select CAST(2 AS money) <= 1;
-- GO
-- select CAST(2 AS money) <= CAST(1 AS int);
-- GO
-- select CAST(2 AS money) <= CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) <= CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) <= CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) <= CAST(1 AS decimal);
-- GO
-- select CAST(2 AS money) <> 1;
-- GO
-- select CAST(2 AS money) <> CAST(1 AS int);
-- GO
-- select CAST(2 AS money) <> CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) <> CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) <> CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) <> CAST(1 AS decimal);
-- select CAST(2 AS money) + 1;
-- GO
-- select CAST(2 AS money) + CAST(1 AS int);
-- GO
-- select CAST(2 AS money) + CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) + CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) + CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) + CAST(1 AS decimal);
-- GO
-- select CAST(2 AS money) - 1;
-- GO
-- select CAST(2 AS money) - CAST(1 AS int);
-- GO
-- select CAST(2 AS money) - CAST(1 AS int2);
-- GO
-- select CAST(2 AS money) - CAST(1 AS int4);
-- GO
-- select CAST(2 AS money) - CAST(1 AS numeric);
-- GO
-- select CAST(2 AS money) - CAST(1 AS decimal);
-- GO
-- select CAST(2 AS money) * 2;
-- GO
-- select CAST(2 AS money) * CAST(2 AS int);
-- GO
-- select CAST(2 AS money) * CAST(2 AS int2);
-- GO
-- select CAST(2 AS money) * CAST(2 AS int4);
-- GO
-- select CAST(2 AS money) * CAST(2 AS numeric);
-- GO
-- select CAST(2 AS money) * CAST(2 AS decimal);
-- GO
-- select CAST(2 AS money) / 0.5;
-- GO
-- select CAST(2 AS money) / CAST(2 AS int);
-- GO
-- select CAST(2 AS money) / CAST(2 AS int2);
-- GO
-- select CAST(2 AS money) / CAST(2 AS int4);
-- GO
-- select CAST(2 AS money) / CAST(0.5 AS numeric(4,2));
-- GO
-- select CAST(2 AS money) / CAST(0.5 AS decimal(4,2));
-- GO
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 111 and character position 22)~~


-- Test DATE, DATETIME, DATETIMEOFFSET, DATETIME2
DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO

-- DATE DATETIME, DATETIMEOFFSET, DATETIME2 and SMALLDATETIME are defined in tsql dialect
select CAST('2020-03-15' AS date);
GO
~~START~~
date
2020-03-15
~~END~~

select CAST('2020-03-15 09:00:00+8' AS datetimeoffset);
GO
~~START~~
datetimeoffset
2020-03-15 09:00:00.0000000 +08:00
~~END~~

select CAST('2020-03-15 09:00:00' AS datetime2);
GO
~~START~~
datetime2
2020-03-15 09:00:00.0000000
~~END~~

select CAST('2020-03-15 09:00:00' AS smalldatetime);
GO
~~START~~
smalldatetime
2020-03-15 09:00:00.0
~~END~~

-- test the range of date
select CAST('0001-01-01' AS date);
GO
~~START~~
date
0001-01-01
~~END~~

select CAST('9999-12-31' AS date);
GO
~~START~~
date
9999-12-31
~~END~~

-- test the range of datetime2
select CAST('0001-01-01 12:00:00.12345' AS datetime2);
GO
~~START~~
datetime2
0001-01-01 12:00:00.1234500
~~END~~

select CAST('9999-12-31 12:00:00.12345' AS datetime2);
GO
~~START~~
datetime2
9999-12-31 12:00:00.1234500
~~END~~

-- precision
select CAST('2020-03-15 09:00:00+8' AS datetimeoffset(7)) ;
GO
~~START~~
datetimeoffset
2020-03-15 09:00:00.000000 +08:00
~~END~~

create table testing_1(ts DATETIME, tstz DATETIMEOFFSET(7));
GO

insert into testing_1 (ts, tstz) values ('2020-03-15 09:00:00', '2020-03-15 09:00:00+8');
select * from testing_1;
drop table testing_1;
GO
~~ROW COUNT: 1~~

~~START~~
datetime#!#datetimeoffset
2020-03-15 09:00:00.0#!#2020-03-15 09:00:00.0000000 +08:00
~~END~~


select CAST('2020-03-15 09:00:00' AS datetime2(7));
GO
~~START~~
datetime2
2020-03-15 09:00:00.000000
~~END~~

select CAST('2020-03-15 09:00:00.123456' AS datetime2(3));
GO
~~START~~
datetime2
2020-03-15 09:00:00.123
~~END~~

select CAST('2020-03-15 09:00:00.123456' AS datetime2(0));
GO
~~START~~
datetime2
2020-03-15 09:00:00
~~END~~

select CAST('2020-03-15 09:00:00.123456' AS datetime2(-1));
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '(' at line 1 and character position 53)~~

create table testing_1(ts DATETIME, tstz DATETIME2(7));
insert into testing_1 (ts, tstz) values ('2020-03-15 09:00:00', '2020-03-15 09:00:00');
select * from testing_1;
GO
~~ROW COUNT: 1~~

~~START~~
datetime#!#datetime2
2020-03-15 09:00:00.0#!#2020-03-15 09:00:00.0000000
~~END~~

drop table testing_1;
GO

-- DATETIME, DATETIMEOFFSET, DATETIME2 and SMALLDATETIME are not defined in
-- postgres dialect
SELECT set_config('babelfishpg_tsql.sql_dialect', 'postgres', false);
GO
~~START~~
text
postgres
~~END~~

select CAST('2020-03-15 09:00:00+8' AS datetimeoffset);
GO
~~START~~
datetimeoffset
2020-03-15 09:00:00.0000000 +08:00
~~END~~

create table testing_1(ts DATETIME);
GO
create table testing_1(tstz DATETIMEOFFSET);
GO
~~ERROR (Code: 2714)~~

~~ERROR (Message: relation "testing_1" already exists)~~

select CAST('2020-03-15 09:00:00' AS datetime2);
GO
~~START~~
datetime2
2020-03-15 09:00:00.0000000
~~END~~

create table testing_1(ts SMALLDATETIME);
GO
~~ERROR (Code: 2714)~~

~~ERROR (Message: relation "testing_1" already exists)~~

create table testing_1(tstz DATETIME2);
GO
~~ERROR (Code: 2714)~~

~~ERROR (Message: relation "testing_1" already exists)~~


-- Test DATETIME, DATETIMEOFFSET, DATETIME2 and SMALLDATETIME can be used as identifier
create table testing_1(DATETIME int);
GO
~~ERROR (Code: 2714)~~

~~ERROR (Message: relation "testing_1" already exists)~~

insert into testing_1 (DATETIME) values (1);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "datetime" of relation "testing_1" does not exist)~~

select * from testing_1;
GO
~~START~~
datetime
~~END~~

drop table testing_1;
GO

create table testing_1(DATETIMEOFFSET int);
GO
insert into testing_1 (DATETIMEOFFSET) values (1);
GO
~~ROW COUNT: 1~~

select * from testing_1;
GO
~~START~~
int
1
~~END~~

drop table testing_1;
GO

create table testing_1(DATETIME2 int);
GO
insert into testing_1 (DATETIME2) values (1);
GO
~~ROW COUNT: 1~~

select * from testing_1;
GO
~~START~~
int
1
~~END~~

drop table testing_1;
GO

create table testing_1(SMALLDATETIME int);
GO
insert into testing_1 (SMALLDATETIME) values (1);
GO
~~ROW COUNT: 1~~

select * from testing_1;
GO
~~START~~
int
1
~~END~~


DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
insert into testing_1 (SMALLDATETIME) values (2);
GO
~~ROW COUNT: 1~~

select * from testing_1;
GO
~~START~~
int
1
2
~~END~~


-- Test conversion between DATE and other date/time types
select CAST(CAST('2020-03-15' AS date) AS datetime);
GO
~~START~~
datetime
2020-03-15 00:00:00.0
~~END~~

select CAST(CAST('2020-03-15' AS date) AS smalldatetime);
GO
~~START~~
smalldatetime
2020-03-15 00:00:00.0
~~END~~

select CAST(CAST('2020-03-15' AS date) AS datetimeoffset(3));
GO
~~START~~
datetimeoffset
2020-03-15 00:00:00.000 +00:00
~~END~~

select CAST(CAST('2020-03-15' AS date) AS datetime2(3));
GO
~~START~~
datetime2
2020-03-15 00:00:00.000
~~END~~


-- Clean up
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 2 and character position 22)~~

drop table testing_1;
GO

-- Test SYS.NCHAR, SYS.NVARCHAR and SYS.VARCHAR
-- nchar is already available in postgres dialect
select CAST('£' AS nchar(1));
GO
~~START~~
nchar
£
~~END~~

-- nvarchar is not available in postgres dialect
select CAST('£' AS nvarchar);
GO
~~START~~
nvarchar
£
~~END~~


-- both are available in tsql dialect
set babelfishpg_tsql.sql_dialect = 'tsql';
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'sql_dialect' at line 2 and character position 21)~~

select CAST('£' AS nchar(2));
GO
~~START~~
nchar
£ 
~~END~~

select CAST('£' AS nvarchar(2));
GO
~~START~~
nvarchar
£
~~END~~


-- multi-byte character doesn't fit in nchar(1) in tsql if it
-- would require a UTF16-surrogate-pair on output
select CAST('£' AS char(1));			-- allowed
GO
~~START~~
char
£
~~END~~

select CAST('£' AS sys.nchar(1));		-- allowed
GO
~~START~~
nchar
£
~~END~~

select CAST('£' AS sys.nvarchar(1));	-- allowed
GO
~~START~~
nvarchar
£
~~END~~

select CAST('£' AS sys.varchar(1));		-- allowed
GO
~~START~~
varchar
£
~~END~~


-- Check that things work the same in postgres dialect
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 2 and character position 22)~~

select CAST('£' AS char(1));
GO
~~START~~
char
£
~~END~~

select CAST('£' AS sys.nchar(1));
GO
~~START~~
nchar
£
~~END~~

select CAST('£' AS sys.nvarchar(1));
GO
~~START~~
nvarchar
£
~~END~~

select CAST('£' AS sys.varchar(1));
GO
~~START~~
varchar
£
~~END~~

set babelfishpg_tsql.sql_dialect = 'tsql';
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'sql_dialect' at line 1 and character position 21)~~


-- truncate input on explicit cast
select CAST('ab' AS char(1));
GO
~~START~~
char
a
~~END~~

select CAST('ab' AS nchar(1));
GO
~~START~~
nchar
a
~~END~~

select CAST('ab' AS nvarchar(1));
GO
~~START~~
nvarchar
a
~~END~~

select CAST('ab' AS sys.varchar(1));
GO
~~START~~
varchar
a
~~END~~



-- default length of nchar/char is 1 in tsql (and pg)
create table testing_1(col nchar);
GO
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 1 and character position 22)~~

SELECT * FROM testing_1;
GO
~~START~~
nchar
~~END~~

DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO

-- check length at insert
insert into testing_1 (col) select 'a';
insert into testing_1 (col) select '£';
insert into testing_1 (col) select 'ab';
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ERROR (Code: 8152)~~

~~ERROR (Message: value too long for type character(1))~~


-- space is automatically truncated
insert into testing_1 (col) select 'c ';
select * from testing_1;
GO
~~ROW COUNT: 1~~

~~START~~
nchar
a
£
c
~~END~~


-- default length of nvarchar in tsql is 1
create table testing_2(col nvarchar);
GO

insert into testing_2 (col) select 'a';
insert into testing_2 (col) select '£';
insert into testing_2 (col) select 'ab';
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ERROR (Code: 8152)~~

~~ERROR (Message: value too long for type character varying(1))~~


-- space is automatically truncated
insert into testing_2 (col) select 'c ';
select * from testing_2;
GO
~~ROW COUNT: 1~~

~~START~~
nvarchar
a
£
c
~~END~~


-- default length of varchar in tsql is 1
create table testing_4(col sys.varchar);
GO

insert into testing_4 (col) select 'a';
insert into testing_4 (col) select '£';
insert into testing_4 (col) select 'ab';
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ERROR (Code: 8152)~~

~~ERROR (Message: value too long for type character varying(1))~~

-- space is automatically truncated
insert into testing_4 (col) select 'c ';
insert into testing_2 (col) select '£ ';
select * from testing_4;
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~START~~
varchar
a
£
c
~~END~~


-- test sys.varchar(max) and sys.nvarchar(max) syntax is allowed in tsql dialect
select CAST('abcdefghijklmn' AS sys.varchar(max));
GO
~~START~~
varchar
abcdefghijklmn
~~END~~

select CAST('abcdefghijklmn' AS varchar(max));
GO
~~START~~
varchar
abcdefghijklmn
~~END~~

select CAST('abcdefghijklmn' AS sys.nvarchar(max));
GO
~~START~~
nvarchar
abcdefghijklmn
~~END~~

select CAST('abcdefghijklmn' AS nvarchar(max));
GO
~~START~~
nvarchar
abcdefghijklmn
~~END~~


-- test char(max), nchar(max) is invalid syntax in tsql dialect
select cast('abc' as char(max));
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Incorrect syntax near the keyword 'bpchar'.)~~

select cast('abc' as nchar(max));
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Incorrect syntax near the keyword 'nchar'.)~~


-- test max can still be used as an identifier
create table max (max int);
insert into max (max) select 100;
select * from max;
GO
~~ROW COUNT: 1~~

~~START~~
int
100
~~END~~

drop table max;
GO

-- test sys.varchar(max) and nvarchar(max) syntax is not allowed in postgres dialect
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 2 and character position 22)~~

select CAST('abcdefghijklmn' AS sys.varchar(max));
GO
~~START~~
varchar
abcdefghijklmn
~~END~~

select CAST('abcdefghijklmn' AS varchar(max));
GO
~~START~~
varchar
abcdefghijklmn
~~END~~

select CAST('abcdefghijklmn' AS sys.nvarchar(max));
GO
~~START~~
nvarchar
abcdefghijklmn
~~END~~

select CAST('abcdefghijklmn' AS nvarchar(max));
GO
~~START~~
nvarchar
abcdefghijklmn
~~END~~


-- test max max character length is (10 * 1024 * 1024) = 10485760
select CAST('abc' AS varchar(10485761));
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: length for type varchar cannot exceed 10485760)~~

select CAST('abc' AS varchar(10485760));
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: The size '10485760' exceeds the maximum allowed (8000) for 'varchar' datatype.)~~


-- test column type nvarchar(max)
DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
create table testing_5(col nvarchar(max));
GO
SELECT * FROM testing_5
GO
~~START~~
nvarchar
~~END~~

DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
insert into testing_5 (col) select 'ab';
insert into testing_5 (col) select 'abcdefghijklmn';
select * from testing_5;
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~START~~
nvarchar
ab
abcdefghijklmn
~~END~~


--test COPY command works with sys.nvarchar
COPY public.testing_5 (col) FROM stdin;
c
ab
abcdefghijk
\.
select * from testing_5;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'public' at line 2 and character position 5)~~


-- [BABEL-220] test varchar(max) as a column
drop table testing_5;
GO

create table testing_5(col varchar(max));
GO
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 1 and character position 22)~~


DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
insert into testing_5 (col) select 'ab';
insert into testing_5 (col) select 'abcdefghijklmn';
select * from testing_5;
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~START~~
varchar
ab
abcdefghijklmn
~~END~~


-- test type modifer persist if babelfishpg_tsql.sql_dialect changes
create table testing_3(col nvarchar(2));
GO

insert into testing_3 (col) select 'ab';
insert into testing_3 (col) select 'a£';
insert into testing_3 (col) select 'a😀';
insert into testing_3 (col) select 'abc';
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ERROR (Code: 33557097)~~

~~ERROR (Message: value too long for type character varying(2) as UTF16 output)~~


reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 1 and character position 22)~~

insert into testing_3 (col) select 'ab';
insert into testing_3 (col) select 'a£';
insert into testing_3 (col) select 'a😀';
insert into testing_3 (col) select 'abc';
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ERROR (Code: 33557097)~~

~~ERROR (Message: value too long for type character varying(2) as UTF16 output)~~


DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
insert into testing_3 (col) select 'ab';
insert into testing_3 (col) select 'a£';
insert into testing_3 (col) select 'a😀';
insert into testing_3 (col) select 'abc';
GO
~~ROW COUNT: 1~~

~~ROW COUNT: 1~~

~~ERROR (Code: 33557097)~~

~~ERROR (Message: value too long for type character varying(2) as UTF16 output)~~


-- test normal create domain works when apg_enable_domain_typmod is enabled
select set_config('enable_seqscan','on','true');
GO
~~START~~
text
on
~~END~~

create domain varchar3 as varchar(3);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'domain' at line 1 and character position 7)~~

select CAST('abc' AS varchar3);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: type "varchar3" does not exist)~~

select CAST('ab£' AS varchar3);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: type "varchar3" does not exist)~~

select CAST('abcd' AS varchar3);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: type "varchar3" does not exist)~~

reset apg_enable_domain_typmod;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: column "apg_enable_domain_typmod" does not exist)~~


-- [BABEL-191] test typmod of sys.varchar/nvarchar engages when the input
-- is casted multiple times
select CAST(CAST('abc' AS text) AS sys.varchar(3));
GO
~~START~~
varchar
abc
~~END~~


select CAST(CAST('abc' AS pg_catalog.varchar(3)) AS sys.varchar(3));
GO
~~START~~
varchar
abc
~~END~~


select CAST(CAST('abc' AS text) AS sys.nvarchar(3));
GO
~~START~~
nvarchar
abc
~~END~~

select CAST(CAST('abc' AS text) AS sys.nchar(3));
GO
~~START~~
nchar
abc
~~END~~


select CAST(CAST(CAST(CAST('abc' AS text) AS sys.varchar(3)) AS sys.nvarchar(3)) AS sys.nchar(3));
GO
~~START~~
nchar
abc
~~END~~


-- test truncation on explicit cast through multiple levels
select CAST(CAST(CAST(CAST('abcde' AS text) AS sys.varchar(5)) AS sys.nvarchar(4)) AS sys.nchar(3));
GO
~~START~~
nchar
abc
~~END~~

select CAST(CAST(CAST(CAST('abcde' AS text) AS sys.varchar(3)) AS sys.nvarchar(4)) AS sys.nchar(5));
GO
~~START~~
nchar
abc  
~~END~~


-- test sys.ntext is available
select CAST('abc£' AS sys.ntext);
GO
~~START~~
ntext
abc£
~~END~~

-- pg_catalog.text
select CAST('abc£' AS text);
GO
~~START~~
text
abc£
~~END~~


-- [BABEL-218] test varchar defaults to sys.varchar in tsql dialect
-- test default length of sys.varchar is 30 in CAST/CONVERT
-- expect the last 'e' to be truncated
select cast('abcdefghijklmnopqrstuvwxyzabcde' as varchar);
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcd
~~END~~

select cast('abcdefghijklmnopqrstuvwxyzabcde' as sys.varchar);
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcd
~~END~~

select convert(varchar, 'abcdefghijklmnopqrstuvwxyzabcde');
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcd
~~END~~

select convert(sys.varchar, 'abcdefghijklmnopqrstuvwxyzabcde');
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcd
~~END~~


-- default length of pg_catalog.varchar is unlimited, no truncation in output
select cast('abcdefghijklmnopqrstuvwxyzabcde' as pg_catalog.varchar);
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcde
~~END~~


-- varchar defaults to pg_catalog.varchar in PG dialect
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 2 and character position 22)~~

select cast('abcdefghijklmnopqrstuvwxyzabcde' as pg_catalog.varchar); -- default length of pg_catalog.varchar is unlimited, no truncation
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcde
~~END~~

DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO

-- [BABEL-255] test nchar defaults to sys.nchar in tsql dialect
create table test_nchar (col1 nchar);
GO

reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 1 and character position 22)~~

SELECT * FROM test_nchar
GO
~~START~~
nchar
~~END~~

DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
drop table test_nchar;
GO

-- test nchar defaults to bpchar in pg dialect
reset babelfishpg_tsql.sql_dialect;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near '.' at line 2 and character position 22)~~

create table test_nchar (col1 nchar);
GO
SELECT * FROM test_nchar
drop table test_nchar;
GO
~~START~~
nchar
~~END~~


DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO

-- [BABEL-257] test varchar defaults to sys.varchar in new
-- database and new schema
SELECT current_database();
GO
~~START~~
varchar
jdbc_testdb
~~END~~


SELECT set_config('babelfishpg_tsql.sql_dialect', 'postgres', false);
GO
~~START~~
text
postgres
~~END~~


CREATE DATABASE demo;
USE demo
GO
CREATE EXTENSION IF NOT EXISTS "babelfishpg_tsql" CASCADE;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'EXTENSION' at line 1 and character position 7)~~

-- Reconnect to make sure CLUSTER_COLLATION_OID is initialized
USE postgres
GO
~~ERROR (Code: 911)~~

~~ERROR (Message: database "postgres" does not exist)~~

USE demo
GO
DECLARE @babelfishpg_tsql_sql_dialect varchar(50) = 'tsql';
GO
-- Test varchar is mapped to sys.varchar
-- Expect truncated output because sys.varchar defaults to sys.varchar(30) in CAST function
select cast('abcdefghijklmnopqrstuvwxyzabcde' as varchar);
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcd
~~END~~

-- Expect non-truncated output because pg_catalog.varchar has unlimited length
select cast('abcdefghijklmnopqrstuvwxyzabcde' as pg_catalog.varchar);
GO
~~START~~
varchar
abcdefghijklmnopqrstuvwxyzabcde
~~END~~


-- Test bit is mapped to sys.bit
-- sys.bit allows numeric input
select CAST(1.5 AS bit);
GO
~~START~~
bit
1
~~END~~

-- pg_catalog.bit doesn't allow numeric input
select CAST(1.5 AS pg_catalog.bit);
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: cannot cast type numeric to bit)~~


-- Test varchar is mapped to sys.varchar in a new schema and a new table
CREATE SCHEMA s1;
GO

create table s1.test1 (col varchar);
GO
-- Test sys.varchar is created for test1.col, expect an error
-- because sys.varchar defaults to sys.varchar(1)
insert into s1.test1 values('abc');
insert into s1.test1 values('a');
select * from s1.test1;
GO
~~ERROR (Code: 8152)~~

~~ERROR (Message: value too long for type character varying(1))~~

~~START~~
varchar
a
~~END~~

drop schema s1 cascade;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: syntax error near 'cascade' at line 1 and character position 15)~~

SELECT set_config('babelfishpg_tsql.sql_dialect', 'postgres', false);
GO
~~START~~
text
postgres
~~END~~


USE regression
GO
~~ERROR (Code: 911)~~

~~ERROR (Message: database "regression" does not exist)~~


drop database demo;
GO
~~ERROR (Code: 33557097)~~

~~ERROR (Message: Cannot drop database "demo" because it is currently in use)~~

